# Serial GC

  - 单线程执行，采用标记-整理算法
  - 看来只适合单CPU下Client模式，应该不太常见了
  - 可以和Parallel Scavenge搭配使用
# CMS GC

  - 使用标记清除算法，多线程分阶段并发标记和清除
  - 适合对服务器的响应速度要求高、多核、低延迟且希望每次GC时间尽量短的场景
  - CMS是基于标记清除算法的，对CPU资源敏感，且会产生空间碎片。不过也可以调节开启碎片整理或者多少不进行碎片处理
  
# Parallel GC

  - 多线程收集器，采用标记-整理算法执行垃圾回收
  - 适合高吞吐量，需要CPU资源最大程度处理业务请求的场景
  - JDK8以前的default GC
  
# G1

  - 通过划分多个内存区域做增量整理和回收，每个区域可能是Eden,Survivor,老年代。而且region 数量也是一直动态变化的
  - 拥有一套可预测的停顿时间模型在有限的时间内可以获得尽可能大的回收效率，进一步降低延迟
  - 垃圾最多的小块会被优先收集
  - 是JDK8+之后的default GC
  - G1适合大内存 (> 8G)，和希望平均GC时间够短可控的场景